#ifndef AST_NODE_H
#define AST_NODE_H

#include "token.h"

#include <stdint.h>
#include <QSharedPointer>
#include <QString>
#include <QVector>
#include <utility>
#include <variant.hpp>

// clang-format off
#define NODE_TYPES(x) \
    x(Nil)            \
    x(Comma)          \
    x(ReverseComma)   \
    x(String)         \
    x(Int)            \
    x(Float)          \
    x(Bool)           \
    x(Cmp)            \
    x(Binary)         \
    x(Variable)       \
    x(FuncCall)       \
    x(Lambda)

// clang-format on

class AstNode {
    using ptr = QSharedPointer<AstNode>; //std::unique_ptr<AstNode>;
public:
    struct Nil {
        Nil() {}
    };
    struct Comma {
        ptr a, b;
        Comma(const ptr& a, const ptr& b) : a(a), b(b) {}
    };
    struct ReverseComma {
        ptr a, b;
        ReverseComma(const ptr& a, const ptr& b) : a(a), b(b) {}
    };
    //struct String { QString str; };
    //struct
    using String = QString;
    using Int = int64_t;
    using Float = double;
    using Bool = bool;
    struct Cmp {
        TT op;
        ptr a, b;
        Cmp(TT op, const ptr& a, const ptr& b) : op(op), a(a), b(b) {}
    };
    struct Binary {
        QString name;
        ptr a, b;
        Binary(const QString& name, const ptr& a, const ptr& b)
            : name(name), a(a), b(b) {}
    };
    struct Variable {
        QString name;
        Variable(const QString& name) : name(name) {}
    };
    struct FuncCall {
        ptr func;
        QVector<ptr> args;
        FuncCall(const ptr& func, const QVector<ptr>& args) : func(func), args(args) {}
    };
    struct Lambda {
        QVector<QString> params, captures;
        ptr body;
        Lambda(const QVector<QString>& params, const ptr& body)
            : params(params), captures(body->freeVars()), body(body) {}
        Lambda(const QVector<QString>& captures, const QVector<QString>& params, const ptr& body)
            : params(params), captures(captures), body(body) {}
    };
    struct MethodCall {
        QString name;
        ptr obj;
        QVector<ptr> args;
        MethodCall(const QString& name, const ptr& obj, const QVector<ptr>& args)
            : name(name), obj(obj), args(args) {}
    };
    struct Assign {
        ptr lvalue, rvalue;
        Assign(const ptr& lvalue, const ptr& rvalue)
            : lvalue(lvalue), rvalue(rvalue) {}
    };
    struct Subscript {
        ptr val, index;
        Subscript(const ptr& val, const ptr& index)
            : val(val), index(index) {}
    };
    struct Member {
        ptr val;
        QString member;
        Member(const ptr& val, const QString& member)
            : val(val), member(member) {}
    };
    struct And {
        ptr a, b;
        And(const ptr& a, const ptr& b) : a(a), b(b) {}
    };
    struct Or {
        ptr a, b;
        Or(const ptr& a, const ptr& b) : a(a), b(b) {}
    };
    struct If {
        ptr cond, body, else_;
        If(const ptr& cond, const ptr& body, const ptr& else_)
            :cond(cond), body(body), else_(else_) {}
    };
    struct While {
        ptr cond, body;
        While(const ptr& cond, const ptr& body) : cond(cond), body(body) {}
    };
    struct For {
        ptr index, val, collection, body;
        For(const ptr& index, const ptr& val, const ptr& collection, const ptr& body)
            : index(index), val(val), collection(collection), body(body) {}
    };
    struct Body {
        QVector<ptr> val;
        Body(const QVector<ptr>& val): val(val){}
    };
    struct Return {
        ptr val;
        Return(const ptr& val) : val(val) {}
    };
    struct CtrlFlow {
        TT type;
        CtrlFlow(TT type) : type(type) {}
    };
    struct List {
        QVector<ptr> val;
        List(const QVector<ptr>& val): val(val){}
    };
    struct Dict {
        QVector<ptr> val;
        Dict(const QVector<ptr>& val): val(val){}
    };

    Pos pos;
#define o(x) x,
    //we add char after NODE_TYPES(o) because in c++ template<args, > is invalid
    mpark::variant<NODE_TYPES(o) char> val;

#undef o

    template<typename T>
    AstNode(Pos pos, const T& val) : pos(pos), val(val) {}

    QString toString(int x = 0) {}

private:
    void freeVarsTail(QVector<QString>& res, const QVector<QString>& bound) {
        //auto fv = [&]()
        mpark::visit([](auto ){}, val);
    }

    /*
    private void freeVarsTail(ref string[] res, string[] bound) {
        void fv(AstNode[] nodes...) {
            foreach (n; nodes) {
                n.freeVarsTail(res, bound);
            }
        }
        void add(string v) {
            import ts.misc;
            if (res.contains(v) || bound.contains(v)) return;
            res ~= v;
        }
        val.visit!(
            (Cmp v) { fv(v.a, v.b); },
            (Comma v) {fv(v.a, v.b); },
            (ReverseComma v) { fv(v.a, v.b); },
            (String v) {},
            (Float v) {},
            (Int v) {},
            (Bool v) {},
            (Nil v) {},
            (Variable v) { add(v.name); },
            (FuncCall v) { fv(v.func); fv(v.args); },
            (Binary v) { fv(v.a, v.b); },
            (MethodCall v) {fv(v.obj); fv(v.args); },
            (Lambda v) { res ~= v.body_.freeVars(bound ~ v.params); },
            (Assign v) { fv(v.rvalue, v.lvalue); },
            (Subscript v) { fv(v.val, v.index); },
            (Member v) { fv(v.val); },
            (And v) { fv(v.a, v.b); },
            (Or v) { fv(v.a, v.b); },
            (If v) { fv(v.cond, v.body_, v.else_); },
            (While v) { fv(v.cond, v.body_); },
            (For v) { add(v.index); add(v.val); fv(v.collection, v.body_); },
            (Body v) { fv(v.val); },
            (List v) {fv(v.val);},
            (Map v) { fv(v.val); },
            (Return v) { fv(v.val); },
            (CtrlFlow v) {},
        )();

    }

    string[] freeVars(string[] bound = []) {
        string[] res;
        freeVarsTail(res, bound);
        return res;
    }

    string toString(int level) {
        import std.conv : to;
        import std.algorithm.iteration;

        auto indent = "";
        for (int i = 0; i < level - 1; ++i) {
            indent ~= "  "; //"    ";
        }
        if (level > 0)
            indent ~= "| ";
        string strSeparated(AstNode[] args, string sep, int level = 0) {
            auto r = "";
            foreach (a; args) {
                r ~= a.toString(level) ~ sep;
            }
            return r;
        }

        ++level;
        string str(AstNode[] args...) {
            auto r = "";
            foreach (a; args) {
                r ~= "\n" ~ (a is null ? "null" : a.toString(level));
            }
            return r;
        }
        //dfmt off
        return indent ~ "-" ~ val.visit!(
            (Cmp v) => format!"cmp '%s':%s"(v.op.symbolicStr, str(v.a, v.b)),
            (Comma v) => format!"comma:%s"(str(v.a, v.b)),
            (ReverseComma v) => format!"reverseComma:%s"(str(v.a, v.b)),
            (String v) => format!`string "%s"`(v.val),
            (Float v) => format!"float %f"(v),
            (Int v) => format!"int %d"(v),
            (Bool v) => format!"bool %s"(v),
            (Nil v) => "nil",
            (Variable v) => format!"variable '%s'"(v.name),
            (FuncCall v) => format!"funcCall:%s%s"(str(v.func), str(v.args)),
            (Binary v) => format!"binary '%s':%s"(v.name, str(v.a, v.b)),
            (MethodCall v) => format!"methodCall '%s':%s%s"(v.name, str(v.obj), str(v.args)),
            (Lambda v) => format!"lambda (%s) [%s]:%s"(v.params.joiner(","), v.captures.joiner(","), str(v.body_)),
            (Assign v) => format!"assign:%s"(str(v.rvalue, v.lvalue)),
            (Subscript v) => format!"subscript:%s"(str(v.val, v.index)),
            (Member v) => format!"member '%s':%s"(v.member, str(v.val)),
            (And v) => format!"and:%s"(str(v.a, v.b)),
            (Or v) => format!"or:%s"(str(v.a, v.b)),
            (If v) => format!"if:%s"(str(v.cond, v.body_, v.else_)),
            (While v) => format!"while:%s"(str(v.cond, v.body_)),
            (For v) => format!"for %s, %s:%s"(v.index, v.val, str(v.collection, v.body_)),
            (Body v) => "body:" ~ str(v.val),
            (List v) => "list:" ~ str(v.val),
            (Map v) => "map:" ~ str(v.val),
            (Return v) => format!"return:%s"(str(v.val)),
            (CtrlFlow v) => v.type.symbolicStr,
        )();
        //dfmt on
    }
}

static foreach (t; types)
    mixin(format!`AstNode ast%s(A...)(Pos pos, A args) {
                      return new AstNode(pos, AstNode.%s(args));
                  }`(t, t));

unittest {
    import std.stdio;

    AstNode[] nodes;
    auto t = astFuncCall(-1, null, nodes);
    //writefln("if='%s'", astIf(-1, null, null, null).toString);
    //assert(t.args.size == 1);
}


     */
};

#undef NODE_TYPES

#endif
