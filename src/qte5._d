// Written in the D programming language.
// MGW Мохов Геннадий Владимирович 2016

module qte5;

import stdd.conv; // Convert to string
import stdd.utf: encode;

alias PTRINT = int;
alias PTRUINT = uint;

struct QtObj__ { PTRINT dummy; } alias QtObjH = QtObj__*;

enum maxLength_pFunQt = 1000;
private void*[maxLength_pFunQt] pFunQt; 				/// Масив указателей на функции из DLL
private uint maxValueInPFunQt;


immutable int QMETHOD = 0; // member type codes
immutable int QSLOT = 1;
immutable int QSIGNAL = 2;

// ----- Описание типов, фактически указание компилятору как вызывать -----
// ----- The description of types, actually instructions to the compiler how to call -----

// Give type Qt. There is an implicit transformation. cast (GetObjQt_t) Z == *Z on any type.
// alias GetObjQt_t = void**; // Дай тип Qt. Происходит неявное преобразование. cast(GetObjQt_t)Z == *Z на любой тип.
private {
	import stdd.string : split;
	static mesNoThisWitoutPar = " without parameters is forbidden!";
	// Generate alias for types call function Qt
	string generateAlias(string ind) {
		string rez;
		string[string] v;
		v["v"]="void";v[""]="";v["t"]="t";v["qp"]="QtObjH";v["i"]="int";
		v["ui"]="uint";v["c"]="char";v["vp"]="void*";v["b"]="bool";v["cp"]="char*";
		v["ip"]="int*";v["vpp"]="void**";v["bool"]="bool";v["us"]="ushort";v["l"]="long";
		auto mas = split(ind, '_');
		rez = "alias " ~ ind ~ " = extern (C) nothrow @nogc " ~ v[mas[1]] ~ " function(";
		foreach(i, el; mas) if(i > 2) rez ~= v[el] ~ ", ";
		rez = rez[0 .. $-2];	rez ~= ");";
		return rez;
	}
	//in: n = nomer function (12), name = name func in library (funCreateQWidget), nameAliasLib = short name DLL/SO (Script)
	//out: funQt(12,bQtE5Script,hQtE5Script,sQtE5Script,"funCreateQWidget", showError);
	string generateFunQt(int n, string name, string nameAliasLib) {
		enum s = "QtE5";
		return "funQt("~to!string(n)~",b"~s~nameAliasLib~",h"~s~ nameAliasLib~",s"~s~nameAliasLib~`,"`~name~`"`~",showError);";
	}

	alias t_QObject_connect = extern (C) @nogc void function(void*, char*, void*, char*, int);
	alias t_QObject_disconnect = extern (C) @nogc void function(void*, char*, void*, char*);

	mixin(generateAlias("t_v__i"));
	mixin(generateAlias("t_v__qp"));
	mixin(generateAlias("t_v__qp_qp"));
	mixin(generateAlias("t_v__qp_vp"));
	mixin(generateAlias("t_v__qp_i"));
	mixin(generateAlias("t_v__qp_i_i_ui"));
	mixin(generateAlias("t_v__vp_c"));
	mixin(generateAlias("t_v__qp_ui"));

	mixin(generateAlias("t_vp__qp"));
	mixin(generateAlias("t_v__vp_vp_vp"));
	mixin(generateAlias("t_v__vp_vp_vp_vp"));
	mixin(generateAlias("t_v__qp_i_i"));
	mixin(generateAlias("t_v__qp_qp_i_i"));
	mixin(generateAlias("t_v__qp_qp_i_i_i"));
	mixin(generateAlias("t_v__qp_qp_i_i_i_i"));
	mixin(generateAlias("t_v__qp_qp_i_i_i_i_i"));

	mixin(generateAlias("t_b__qp"));
	mixin(generateAlias("t_b__qp_qp"));
	mixin(generateAlias("t_b__qp_qp_qp"));
	mixin(generateAlias("t_b__qp_qp_qp_i"));
	mixin(generateAlias("t_b__qp_qp_i"));
	mixin(generateAlias("t_b__qp_i"));
	mixin(generateAlias("t_b__qp_i_i_i"));
	mixin(generateAlias("t_b__qp_i_i"));
	mixin(generateAlias("t_b__qp_qp_i_i"));

	mixin(generateAlias("t_v__qp_qp_i"));
	mixin(generateAlias("t_v__qp_qp_qp_i"));
	mixin(generateAlias("t_v__qp_qp_qp_i_i"));
	mixin(generateAlias("t_v__qp_qp_qp"));
	mixin(generateAlias("t_v__qp_qp_qp_qp_i"));
	mixin(generateAlias("t_i__qp_qp_qp"));

	mixin(generateAlias("t_v__qp_i_i_i_i_i"));
	mixin(generateAlias("t_v__qp_ip_ip_ip_ip"));

	mixin(generateAlias("t_v__vp_vp_i"));
	mixin(generateAlias("t_i__vp_vp_vp"));
	mixin(generateAlias("t_i__vp_i"));
	mixin(generateAlias("t_i__qp_i"));
	mixin(generateAlias("t_i__qp_qp"));
	mixin(generateAlias("t_i__qp_i_i"));
	mixin(generateAlias("t_i__qp_qp_i"));
	mixin(generateAlias("t_qp__qp_qp"));
	mixin(generateAlias("t_vp__vp_c_i"));
	mixin(generateAlias("t_vp__vp_cp_i"));
	mixin(generateAlias("t_i__qp_qp_qp_i_i"));

	mixin(generateAlias("t_vpp__vp"));
	mixin(generateAlias("t_qp__qp"));
	mixin(generateAlias("t_qp__ui"));
	mixin(generateAlias("t_qp__vp"));

	mixin(generateAlias("t_vp__vp"));
	mixin(generateAlias("t_vp__vp_i_i"));
	mixin(generateAlias("t_vp__vp_i_vp"));

	mixin(generateAlias("t_vp__vp_vp_i"));
	mixin(generateAlias("t_qp__qp_qp_i"));
	mixin(generateAlias("t_vp__vp_i"));
	mixin(generateAlias("t_qp__qp_i"));
	mixin(generateAlias("t_qp__qp_b"));
	mixin(generateAlias("t_ui__qp_i_i"));
	mixin(generateAlias("t_ui__qp"));
	mixin(generateAlias("t_qp__qp_i_i"));
	alias t_vp__v = extern (C) @nogc void* function();
	alias t_qp__v = extern (C) @nogc QtObjH function();
	mixin(generateAlias("t_i__vp"));
	mixin(generateAlias("t_i__qp"));

	mixin(generateAlias("t_v__qp_b_i_i"));
	mixin(generateAlias("t_v__qp_b_i"));

	mixin(generateAlias("t_vp__i_i"));
	mixin(generateAlias("t_qp__i_i"));
	mixin(generateAlias("t_qp__i_i_i"));
	mixin(generateAlias("t_qp__i"));

	mixin(generateAlias("t_vp__i_i_i_i"));

	// mixin(generateAlias("t_v__vp_i_bool"));
	mixin(generateAlias("t_v__vp_i_i_i_i"));
	mixin(generateAlias("t_v__qp_i_i_i_i"));
	mixin(generateAlias("t_v__qp_i_i_i"));
	mixin(generateAlias("t_v__vp_i_i_vp"));
	mixin(generateAlias("t_v__i_vp_vp"));
	// mixin(generateAlias("t_vp__vp_vp_bool"));
	// mixin(generateAlias("t_vp__i_vp_bool"));
	alias t_i__v = extern (C) @nogc int function();
	// mixin(generateAlias("t_i__vp_vbool_i"));

	mixin(generateAlias("t_vp__vp_i_vp_i"));
	mixin(generateAlias("t_vp__vp_i_i_vp"));
	mixin(generateAlias("t_vp__vp_vp_i_i"));
	mixin(generateAlias("t_i__vp_vp_i_i"));

	mixin(generateAlias("t_vp__vp_vp_us_i"));
	mixin(generateAlias("t_v__vp_vp_us_i"));
	mixin(generateAlias("t_bool__vp"));
	mixin(generateAlias("t_bool__vp_c"));
	mixin(generateAlias("t_bool__vp_vp"));
	mixin(generateAlias("t_v__qp_bool"));
	mixin(generateAlias("t_v__qp_b"));
	mixin(generateAlias("t_v__vp_i_vp_us_i"));
	mixin(generateAlias("t_vp__vp_vp_vp"));

	mixin(generateAlias("t_l__vp_vp_l"));
	mixin(generateAlias("t_l__vp"));

	mixin(generateAlias("t_vp__vp_vp_vp_vp_vp_vp_vp"));
	mixin(generateAlias("t_vp__vp_vp_vp_vp_vp_vp_vp_vp"));

	alias t_ub__qp = extern (C) @nogc ubyte* function(QtObjH);
	alias t_uwc__qp = extern (C) @nogc wchar* function(QtObjH);
}

char* MSS(string s, int n) {
	if (n == QMETHOD)	return cast(char*)("0" ~ s ~ "\0").ptr;
	if (n == QSLOT) 	return cast(char*)("1" ~ s ~ "\0").ptr;
	if (n == QSIGNAL)	return cast(char*)("2" ~ s ~ "\0").ptr;
	return null;
} /// Моделирует макросы QT. Model macros Qt. For n=2->SIGNAL(), n=1->SLOT(), n=0->METHOD().



// Две этих переменных служат для поиска ошибок связанных с ошибочным
// уничтожением объектов C++
static int allCreate;
static int balCreate;
// Переменная для анализа распределения памяти
static int id;
static QtObjH saveAppPtrQt;

class QObject {
	// Тип связи сигнал - слот
	enum ConnectionType {
		AutoConnection = 0,				// default. Если thred другой, то в очередь, иначе сразу выполнение
		DirectConnection = 1,			// Выполнить немедленно
		QueuedConnection = 2,			// Сигнал в очередь
		BlockingQueuedConnection = 4,	// Только для разных thred
		UniqueConnection = 0x80,		// Как AutoConnection, но обязательно уникальный
		AutoCompatConnection = 3 		// совместимость с Qt3
	}

	private QtObjH p_QObject; /// Адрес самого объекта из C++ Qt
	private bool  fNoDelete;  /// Если T - не вызывать деструктор
	private void* adrThis;    /// Адрес собственного экземпляра

	// int id;

	this() {
		// Для подсчета ссылок создания и удаления
		balCreate++;
		allCreate++; id = allCreate;
		// if(balCreate < 10)
		//	 { printf("+[%d]-[%d]-[%p]->[%p] ", id, balCreate, this, fNoDelete, QtObj); writeln(this);  stdout.flush(); }

	} /// спец Конструктор, что бы не делать реальный объект из Qt при наследовании
	~this() {
		// Для подсчета ссылок создания и удаления
		balCreate--;
		// if(balCreate < 10)
		//	{ printf("-[%d]-[%d]-[%p] %d ->[%p] ", id, balCreate, this, fNoDelete, QtObj); writeln(this);   stdout.flush(); }

		if(balCreate == 0) {
		 	//writeln("    delete app ... ", QtObj, "  ", this);  stdout.flush();
		 	(cast(t_v__qp) pFunQt[3])(saveAppPtrQt); // setQtObj(null);
		}
	}
	// Ни чего в голову не лезет ... Нужно сделать объект, записав в него пришедший
	// с наружи указатель. Дабы отличить нужный конструктор, специально делаю
	// этот конструктор "вычурным"
	// this(char ch, void* adr) {
	//	if(ch == '+') setQtObj(cast(QtObjH)adr);
	//}
	void setNoDelete(bool f) { //->
		fNoDelete = f;
	}
	@property bool NoDelete() { //->
		return fNoDelete; }

	void setQtObj(QtObjH adr) { //->
		p_QObject = adr; } /// Заменить указатель в объекте на новый указатель

	@property QtObjH QtObj() { //->
		return p_QObject;
	} /// Выдать указатель на реальный объект Qt C++
	@property void* aQtObj() { //->
		return &p_QObject;
	} /// Выдать указатель на p_QObject
	QObject connect(void* obj1, char* ssignal, void* obj2, char* sslot,	QObject.ConnectionType type = QObject.ConnectionType.AutoConnection) { //->
		(cast(t_QObject_connect) pFunQt[27])(obj1, ssignal, obj2, sslot, cast(int)type);
		return this;
	}
	QObject connects(QObject obj1, string ssignal, QObject obj2, string sslot) { //->
		(cast(t_QObject_connect) pFunQt[27])(
			(cast(QObject)obj1).QtObj, MSS(ssignal, QSIGNAL),
			(cast(QObject)obj2).QtObj, MSS(sslot, QSLOT),
		cast(int)QObject.ConnectionType.AutoConnection);
		return this;
	}
	QObject disconnects(QObject obj1, string ssignal, QObject obj2, string sslot) { //->
		(cast(t_QObject_disconnect) pFunQt[343])(
			(cast(QObject)obj1).QtObj, MSS(ssignal, QSIGNAL),
			(cast(QObject)obj2).QtObj, MSS(sslot, QSLOT));
		return this;
	}
	/// Запомнить указатель на собственный экземпляр
	void saveThis(void* adr) { //-> Запомнить указатель на собственный экземпляр
		adrThis = adr;
	}
	@property void* aThis() { //-> Выдать указатель на p_QObject
		return &adrThis;
	} /// Выдать указатель на p_QObject
	void* parentQtObj() { //-> выдать указатель на собственного родителя в Qt
		return (cast(t_qp__qp)pFunQt[344])(QtObj);
	}
	void setObjectName(T)(T name) { //-> Задать имя объекту
		wstring ps = to!wstring(name);
		(cast(t_v__qp_qp) pFunQt[381])(QtObj, (cast(t_qp__qp_i)pFunQt[9])(cast(QtObjH)ps.ptr, cast(int)ps.length));
	}
	T objectName(T)() { //-> Получить имя объекта
		QString qs = new QString();	(cast(t_qp__qp_qp)pFunQt[382])(QtObj, qs.QtObj);
		return cast(T)qs.String();
	}
	void dumpObjectInfo() {
		(cast(t_qp__qp_i)pFunQt[383])(QtObj, 0);
	}
	void dumpObjectTree() {
		(cast(t_qp__qp_i)pFunQt[383])(QtObj, 1);
	}
}
// =============== sQString ================
private {
	QtObjH f_9(wstring ps) {
		return (cast(t_qp__qp_i)pFunQt[9])(cast(QtObjH)ps.ptr, cast(int)ps.length);
	}
	string f_18_19(QtObjH qp) {
		wchar* wc = (cast(t_uwc__qp) pFunQt[18])(qp);
		int  size = (cast(t_i__qp) pFunQt[19]) (qp);
		char[] buf; for (int i; i != size; i++) { encode(buf, *(wc + i)); }
		return  to!string(buf);
	}
}
/*
struct sQString {
	//____________________________
private:
	QtObjH adrCppObj;
	//____________________________
public:
	@disable this();
	@property QtObjH QtObj()	{ 	return adrCppObj;	}
	void setQtObj(QtObjH adr)	{ 	adrCppObj = adr; 	}
	//____________________________
	~this() { (cast(t_v__qp) pFunQt[10])(QtObj);  }
	this(T)(T s) {
		setQtObj(f_9(to!wstring(s)));
	} /// Конструктор где s - Utf-8. Пример: QString qs = new QString("Привет!");
	this(char ch, void* adr) {
		if(ch == '+') setQtObj(cast(QtObjH)adr); // fNoDelete = true;
	}
	int size() { //-> Размер в UNICODE символах
		return (cast(t_i__qp) pFunQt[19])(QtObj);
	} /// Размер в UNICODE символах
	ubyte* data() { //-> Указатель на UNICODE
		return (cast(t_ub__qp) pFunQt[18])(QtObj);
	} /// Указатель на UNICODE
	string toUtf8() { //-> Конвертировать внутреннее представление в wstring
		return f_18_19(QtObj);
	} /// Конвертировать внутреннее представление в wstring
	@property string String() { //-> return string D from QString
		return toUtf8();
	} /// return string D from QString
}*/
// ================ QString ================
class QString: QObject {
	// this() - допустим, если тет наследования C++
	this()  { setQtObj((cast(t_qp__v)pFunQt[8])());	}
	// Обязателен косвенный вызов (баг D)
	~this() { del(); }
	void del() { 
		if(!fNoDelete && (QtObj !is null)) { (cast(t_v__qp)pFunQt[10])(QtObj); setQtObj(null); }	
	}
	this(T)(T s) {
		setQtObj(f_9(to!wstring(s)));
	} /// Конструктор где s - Utf-8. Пример: QString qs = new QString("Привет!");
	this(QtObjH adr) { setQtObj(adr);
	} /// Изготовить QString из пришедшего из вне указателя на C++ QString
	this(char ch, void* adr) {
		if(ch == '+') setQtObj(cast(QtObjH)adr); fNoDelete = true;
	}
	int size() { //-> Размер в UNICODE символах
		return (cast(t_i__qp) pFunQt[19])(QtObj);
	} /// Размер в UNICODE символах
	ubyte* data() { //-> Указатель на UNICODE
		return (cast(t_ub__qp) pFunQt[18])(QtObj);
	} /// Указатель на UNICODE
	string toUtf8() { //-> Конвертировать внутреннее представление в wstring
		return f_18_19(QtObj);
	} /// Конвертировать внутреннее представление в wstring
	@property string String() { //-> return string D from QString
		return toUtf8();
	} /// return string D from QString
	int sizeOfQString() { //->
		return (cast(t_i__v) pFunQt[281])();
	}
}
